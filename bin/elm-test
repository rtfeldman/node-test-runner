#!/usr/bin/env node

var processTitle = "elm-test";

process.title = processTitle;

process.on('uncaughtException', function(error) {
  if (/ an argument in Javascript/.test(error)) {
    // Handle arg mismatch between js and elm code. Expected message from Elm:
    // "You are giving module `Main` an argument in JavaScript.
    // This module does not take arguments though! You probably need to change the
    // initialization code to something like `Elm.Test.Generated.Main.fullscreen()`]"
    console.error("Error starting the node-test-runner.");
    console.error("Please check your Javascript 'elm-test' and Elm 'node-test-runner' package versions are compatible");
  } else {
    console.error("Unhandled exception while running the tests:", error);
  }
});

var compile    = require("node-elm-compiler").compile,
  fs           = require("fs-extra"),
  glob         = require("glob"),
  chalk        = require("chalk"),
  builder      = require("xmlbuilder"),
  path         = require("path"),
  temp         = require("temp").track(), // Automatically cleans up temp files.
  util         = require("util"),
  _            = require("lodash"),
  spawn        = require("cross-spawn"),
  minimist     = require("minimist"),
  firstline    = require("firstline"),
  chokidar     = require("chokidar"),
  Runner       = require("../lib/runner.js"),
  Init         = require("../lib/init.js"),
  doctest      = require("elm-doc-test/bin/modes");

var generatedCodeDir = "elm-stuff/generated-code/elm-community/elm-test"
var elm = {
  'elm-package': 'elm-package'
};
var args = minimist(process.argv.slice(2), {
    alias: {
        'help': 'h',
        'yes': 'y',
        'fuzz': 'f',
        'seed': 's',
        'compiler': 'c',
        'report': 'r',
        'watch': 'w'
    },
    boolean: ['yes', 'warn', 'version', 'help', 'watch'],
    string: ['compiler', 'seed', 'report', 'fuzz']
});

// TODO on macOS if you give it a glob as its last argument, Node translates
// that into a list of file paths. Do we get the same result on Windows?
// If not, we need to do custom glob handling there.
var testFilePaths = (args._.length > 0 ? args._ : glob.sync(
    "test/suites/**/*.elm",
    {nocase: true, ignore: "**/elm-stuff/**", nodir: true}
  )).map(function(filename) { return path.resolve(filename); });
var pathToMake = undefined;

if (args.help) {
  console.log("Usage: elm-test init [--yes]  # Create example tests\n");
  console.log("Usage: elm-test TESTFILE [--compiler /path/to/compiler] # Run TESTFILE\n");
  console.log("Usage: elm-test [--compiler /path/to/compiler] # Run tests/\n");
  console.log("Usage: elm-test [--seed integer] # Run with initial fuzzer seed\n");
  console.log("Usage: elm-test [--report json, junit, or chalk (default)] # Print results to stdout in given format\n");
  console.log("Usage: elm-test [--watch] # Run tests on file changes\n");
  process.exit(1);
}

if (args.version) {
  console.log(require(path.join(__dirname, "..", "package.json")).version);
  process.exit(0);
}

var elmRootDir = Runner.findNearestElmPackageDir(testFilePaths);
var elmPackagePath = path.resolve(path.join(elmRootDir, "elm-package.json"));

function runTests (testFile) {
  // TODO compile to elm-stuff/generated-code to avoid unnecessary recompilation
  temp.open({ prefix:'elm_test_', suffix:'.js' }, function(err, info) {
      var dest = info.path;
      var compileProcess = compile( [testFile], {
          output: dest,
          verbose: args.verbose,
          yes: true,
          spawn: spawnCompiler,
          pathToMake: pathToMake,
          warn:args.warn
      });

      compileProcess.on('close', function(exitCode) {
        if (exitCode !== 0) {
          console.error("Compilation failed for", testFile);
          if (!args.watch) {
            process.exit(exitCode);
          }
        } else {
          try {
            Runner.evalElmCode(args, report, fs.readFileSync(dest, {encoding: "utf8"}), "Main");
          } catch (err) {
            console.error("The test run failed because it encountered a runtime exception:\n\n", err);

            if (!args.watch) {
              process.exit(2);
            }
          }
        }
      });
  });
}

function runElmTest() {
  process.chdir(elmRootDir);

  checkNodeVersion();

  function checkNodeVersion() {
    var nodeVersionString = process.versions.node;
    var nodeVersion = _.map(_.split(nodeVersionString, '.'), _.parseInt);

    if((nodeVersion[0] === 0 && nodeVersion[1] < 11) ||
       (nodeVersion[0] === 0 && nodeVersion[1] === 11 && nodeVersion[2] < 13)) {
      console.log("using node v" + nodeVersionString);
      console.error("elm-test requires node v4.7.0 or greater - upgrade the installed version of node and try again");
      process.exit(1);
    }
  }

  if (args._[0] == "init") {
    Init.init(args);

    process.exit(0);
  }

  var testsPath = args._[0],
      pathToMake = undefined;

  if (args.compiler !== undefined) {
    pathToMake = args.compiler;

    if (!pathToMake) {
      console.error("The --compiler option must be given a path to an elm-make executable.");
      process.exit(1);
    }
  }

  function infoLog(msg) {
    if (report === "chalk") {
      console.log(msg);
    }
  }

  // TODO we don't want to do this every single time. Instead,
  // verify that the generated elm-package.json is there, with the
  // expected version number. Iff the version number is wrong, regenerate.
  var newElmPackageDir = path.resolve(generatedCodeDir);
  var generatedSrc = path.join(newElmPackageDir, "src");

  var elmPackageContents;

  try {
    elmPackageContents = fs.readJsonSync(elmPackagePath);
  } catch (err) {
    console.error("Error reading elm-package.json: " + err);
    process.exit(1);
  }

  // Enable Native modules in the new elm-package.json, so we can import
  // the function that translates runtime exceptions into test failures.
  elmPackageContents["native-modules"] = true;

  // Make all the source-directories absolute, and introduce a new one.
  var sourceDirs = (elmPackageContents["source-directories"] || []).map(function(src) {
    return path.resolve(src)
  });

  elmPackageContents["source-directories"] = [
    // Include elm-stuff/generated-sources - since we'll be generating sources in there.
    generatedSrc,

    // Include node-test-runner's src directory, to allow access to the Runner code.
    path.resolve(path.join(__dirname, "..", "src"))
  ].concat(sourceDirs)

  fs.mkdirpSync(newElmPackageDir);

  // Generate the new elm-package.json
  fs.writeFileSync(
    path.join(newElmPackageDir, "elm-package.json"),
    JSON.stringify(elmPackageContents, null, 4)
  );

  // Copy all the native-src files over. These need to be "localized" - that is,
  // in js they cannot define things using rtfeldman$node_test_runner - but rather
  // must use the appropriate package name from the elm-package.json we're copying.
  Runner.copyNativeSrcFiles(
    Runner.repositoryToNativePackageName(elmPackageContents.repository),
    path.join(__dirname, "..", "native-src"),
    generatedSrc
  );

  process.chdir(newElmPackageDir);

  Promise.all(testFilePaths.map(Runner.toModuleName)).then(function(moduleNames) {
    var imports = new Set();
    var testList = new Set();
    var doctestSet = new Set(doctestModel.config.tests);
    var testModuleSet = new Set(moduleNames);

    // Building things like:
    //
    // import MyTests
    //
    // MyTests.suite
    moduleNames.forEach(function(moduleName) {
      testList.add(moduleName + ".suite");

      imports.add("import " + moduleName);
    });

    doctestModel.config.tests.forEach(function(moduleName) {
      testList.add("Doc." + moduleName + "Spec.spec");

      imports.add("import Doc." + moduleName + "Spec");
    });

    var fuzz = parseInt(args.fuzz);
    var seed = parseInt(args.seed);
    var opts =
      {
        fuzz : isNaN(fuzz) ? "Nothing" : "Just " + fuzz,
        seed : isNaN(seed) ? "Nothing" : "Just " + seed
      }

    var optsCode = "{ runs = " + opts.fuzz + ", seed = " + opts.seed + "}"

    var testFileContents =
      [ "port module Test.Generated.Main exposing (main)"
      , ""
      , Array.from(imports).join("\n")
      , ""
      , "import Test.Runner.Node"
      , "import Test"
      , "import Json.Encode"
      , ""
      , "port emit : ( String, Json.Encode.Value ) -> Cmd msg"
      , ""
      , "main : Test.Runner.Node.TestProgram"
      , "main ="
      , "    [ " + Array.from(testList).join(", ") + " ]"
      , "        |> Test.concat"
      , "        |> Test.Runner.Node.runWithOptions " + optsCode + " emit"
      ].join("\n");

    var testFile = path.join(generatedSrc, "Main.elm");

    fs.writeFileSync(testFile, testFileContents);

    if (args.watch) {
      infoLog('Running in watch mode');

      var watchedPaths = JSON.parse(fs.readFileSync(elmPackagePath, 'utf8'))['source-directories'].map(function(path) { return path + '/**/*.elm'; });
      var watcher = chokidar.watch(watchedPaths, {ignoreInitial: true, ignored: /(\/|^)elm-stuff(\/|$)/});

      var eventNameMap = {
          add: 'added',
          addDir: 'added',
          change: 'changed',
          unlink: 'removed',
          unlinkDir: 'removed',
      };

      watcher.on('all', function (event, filePath) {
          var relativePath = path.relative(elmRootDir, filePath);
          var eventName = eventNameMap[event] || event;

          infoLog('\n' + relativePath + ' ' + eventName + '. Rebuilding!');

          runTests(testFile);
      });
    }

    runTests(testFile);
  }).catch(function(err) {
    console.error("Error reading source files", err);
    process.exit(1);
  });
}

var report;

if (args.report === "chalk" || args.report === "json" || args.report === "junit") {
    report = args.report;
} else if (args.report !== undefined) {
    console.error("The --report option must be given either 'chalk', 'junit', or 'json'");
    process.exit(1);
} else {
  report = "chalk";
}

function spawnCompiler(cmd, args, opts) {
  var compilerOpts =
      _.defaults({stdio: [process.stdin, report === "chalk" ? process.stdout : 'ignore', process.stderr] }, opts);

  return spawn(cmd, args, compilerOpts);
}

// Run elm-doc-tests
var doctestModel = doctest.init({
  warn: false,
  output: path.join(elmRootDir, generatedCodeDir, "src")
});

if (doctestModel.config.tests.length <= 0) {
  runElmTest(); // only run elm-tests
} else {
  doctestModel.run(doctestModel, function () {
    // Run elm-tests
    runElmTest();
  });
}
